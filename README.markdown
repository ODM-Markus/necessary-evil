# necessary-evil

*necessary-evil* is an implementation of [XML-RPC](http://xml-rpc.com/)
built on top of the [ring http
library](https://github.com/mmcgrana/ring) for Clojure. XML-RPC is a
bit nasty, but it is the basis of a number of other standards such as
certain blogging APIs and Ping Back.

Thanks to [Raynes](https://github.com/Raynes/) for feedback and letting me steal from his `clj-xmlrpc` code.

## Usage

    (require '[necessary-evil.core :as xml-rpc])

Making a client request is very simple:

    (xml-rpc/call "http://example.com/rpc" :hello "World") 

This will either return a clojure data structure or, if there is a fault, a `necessary-evil.methodresponse.Fault` record. For the example above, you might expect something like `"Hello, World!"` to be returned. See xml-rpc mappings below for details of how xml-rpc data is converted to clojure data and vice versa.

Call accepts the arguments to the remote method as varags after the method name.

Here is a simple hello world request handler:

    (use 'ring.adapter.jetty)
    
    (def handler (xml-rpc/end-point 
        {:hello (fn hello 
            ([] (hello "World"))
            ([name] (str "Hello, " name "!")))}))
    
    (run-jetty handler {:port 3000 :join? false})

Methods are :keyword iFn pairs in the method map passed to end-point. 

As XML-RPC requests are always HTTP POST requests, necessary-evil implements a very bare bones GET handler that returns a comma separated list of method names. 

The handler generated by end-point should work properly with any other ring handler, and should play nice with middleware or any other ring library such as [compojure](https://github.com/weavejester/compojure/) or [moustache](https://github.com/cgrand/moustache).

### Moustache example:

The following is a trivial example to attach an xml-rpc endpoint into a hello world moustache application:

    (require '[necessary-evil.core :as xmlrpc])  
    (use 'ring.adapter.jetty)   
    (use 'net.cgrand.moustache)                                        
    
    (def ep (xmlrpc/end-point 
                {:hello (fn [n] (str "Hello, " n "!"))}))
    (def handler (app 
        ["hello"] {:get "Hello!"} 
        ["xml"] ep))
    
    (run-jetty #'handler {:port 3000 :join? false})

In this application `/` is a 404, `/hello` returns "Hello!", and `/xml` is the xmlrpc handler.

### xml-rpc mappings

This table describes the mapping of clojure datastructures and types
to XML-RPC types

<table style="width: 100%">
    <thead>
    <tr><th>XML-RPC Element</th><th>Clojure or Java type</th></tr>
    </thead>
    <tbody>
        <tr><td>array</td><td>clojure.lang.IPersistentVector</td></tr>
        <tr><td>base64</td><td>byte-array</td></tr>
        <tr><td>boolean</td><td>java.lang.Boolean</td></tr>
        <tr><td>dateTime.iso8601</td><td>org.joda.time.DateTime</td></tr>
        <tr><td>double</td><td>java.lang.Double</td></tr>
        <tr><td>i4</td><td>java.lang.Integer</td></tr>
        <tr><td>int</td><td>java.lang.Integer</td></tr>
        <tr><td>struct</td><td>clojure.lang.IPersistantMap â€”
    <em>String keys</em></td></tr>
        <tr><td><em>no element</em></td><td>java.lang.String</td></tr>
    </tbody>
</table>

**Note:** `nil` is conspicuously absent from the list of types; this is because the spec for xml-rpc itself does not include any canonical representation.

It is possible to extend the support to additional data types trivially. All the details of parsing and unparsing the various value types is handled in the `necessary-evil.value` namespace with the multimethod `parse-value` and the protocol `ValueTypeElem`. Simple implement the appropriate pair for each of these in your own code.

## API Documentation

The follow API documentation is available at [http://brehaut.github.com/necessary-evil/](http://brehaut.github.com/necessary-evil/)

## Changes from 1.1 to 2.0

 * Following the change from keywords to strings for methodcalls,
   structs now use string keys for the same reason.

## Changes from 1.0 to 1.1

 * `fault` handling code is now in its own namespace: `necessary-evil.fault`
   * `necessary-evil.fault` now includes `attempt-all` macro to stream line 
     writing code that may generate faults in multiple stages.
 * Internally an endpoint's method map is a map of strings to functions rather 
   than keywords to functions; This is because keyword's names are interned in 
   permgen in the JVM; This would allow a malicious client to cause OOM errors by 
   generating malicious method names. See [Clojure's keyword can fill up your PermGen space](http://www.xcombinator.com/2011/03/02/clojures-keyword-can-fill-up-your-permgen-space/) for more details.


## License

Copyright (C) 2010, 2011 Andrew Brehaut

Distributed under the Eclipse Public License, the same as Clojure.


