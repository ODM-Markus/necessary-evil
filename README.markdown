
# necessary-evil

*necessary-evil* is an implementation of [XML-RPC](http://xml-rpc.com/)
built on top of the [ring http
library](https://github.com/mmcgrana/ring) for Clojure. XML-RPC is a
bit nasty, but it is the basis of a number of other standards such as
certain blogging APIs and Ping Back.

Thanks to [Raynes](https://github.com/Raynes/) for feedback and letting me steal from his `clj-xmlrpc` code.

## Usage

    (require '[necessary-evil.core :as xml-rpc])

Making a client request is very simple:

    (xml-rpc/call "http://example.com/rpc" :hello "World") 

This will either return a clojure data structure or, if there is a fault, a `necessary-evil.methodresponse.Fault` record. For the example above, you might expect something like `"Hello, World!"` to be returned. See xml-rpc mappings below for details of how xml-rpc data is converted to clojure data and vice versa.

Call accepts the arguments to the remote method as varags after the method name.

Here is a simple hello world request handler:

    (use 'ring.adapter.jetty)
    
    (def handler (xml-rpc/end-point 
        {:hello (fn hello 
            ([] (hello "World"))
            ([name] (str "Hello, " name "!")))}))
    
    (run-jetty handler {:port 3000})

Methods are :keyword iFn pairs in the method map passed to end-point. 

As XML-RPC requests are always HTTP POST requests, necessary-evil implements a very bare bones GET handler that returns a comma separated list of method names. 

The handler generated by end-point should work properly with any other ring handler, and should play nice with middleware or any other ring library such as compojure or moustache.

### xml-rpc mappings

This table describes the mapping of clojure datastructures and types
to XML-RPC types

<table style="width: 100%">
    <thead>
    <tr><th>XML-RPC Element</th><th>Clojure or Java type</th></tr>
    </thead>
    <tbody>
        <tr><td>array</td><td>clojure.lang.IPersistentVector</td></tr>
        <tr><td>base64</td><td>byte-array</td></tr>
        <tr><td>boolean</td><td>java.lang.Boolean</td></tr>
        <tr><td>dateTime.iso8601</td><td>org.joda.time.DateTime</td></tr>
        <tr><td>double</td><td>java.lang.Double</td></tr>
        <tr><td>i4</td><td>java.lang.Integer</td></tr>
        <tr><td>int</td><td>java.lang.Integer</td></tr>
        <tr><td>struct</td><td>clojure.lang.IPersistantMap â€” <em>clojure.lang.Keyword keys</em></td></tr>
        <tr><td><em>no element</em></td><td>java.lang.String</td></tr>
    </tbody>
</table>

It is possible to extend the support to additional data types trivially. All the details of parsing and unparsing the various value types is handled in the `necessary-evil.value` namespace with the multimethod `parse-value` and the protocol `ValueTypeElem`. Simple implement the appropriate pair for each of these in your own code.

## License

Copyright (C) 2010 Andrew Brehaut

Distributed under the Eclipse Public License, the same as Clojure.
