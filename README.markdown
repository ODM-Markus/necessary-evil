        
# necessary-evil

*necessary-evil* is an implementation of [XML-RPC](http://xml-rpc.com/)
built on top of the [ring http
library](https://github.com/mmcgrana/ring) for Clojure. XML-RPC is a
bit nasty, but it is the basis of a number of other standards such as
certain blogging APIs and Ping Back.

`necessary-evil` will only with with Java 6+. 

## Usage

    (require '[necessary-evil.core :as xml-rpc])

Making a client request is very simple:

    (xml-rpc/call "http://example.com/rpc" :hello "World") 

This will either return a clojure data structure or, if there is a fault, a `necessary-evil.methodresponse.Fault` record. For the example above, you might expect something like `"Hello, World!"` to be returned. See xml-rpc mappings below for details of how xml-rpc data is converted to clojure data and vice versa.

Call accepts the arguments to the remote method as varags after the method name.

Here is a simple hello world request handler:

    (use 'ring.adapter.jetty)
    
    (def handler (xml-rpc/end-point 
        {:hello (fn hello 
            ([] (hello "World"))
            ([name] (str "Hello, " name "!")))}))
    
    (run-jetty handler {:port 3000 :join? false})

Methods are :keyword iFn pairs in the method map passed to end-point. 

As XML-RPC requests are always HTTP POST requests, necessary-evil implements a very bare bones GET handler that returns a comma separated list of method names. 

The handler generated by end-point should work properly with any other ring handler, and should play nice with middleware or any other ring library such as [compojure](https://github.com/weavejester/compojure/) or [moustache](https://github.com/cgrand/moustache).

### Moustache example:

The following is a trivial example to attach an xml-rpc endpoint into a hello world moustache application:

    (require '[necessary-evil.core :as xmlrpc])  
    (use 'ring.adapter.jetty)   
    (use 'net.cgrand.moustache)                                        
    
    (def ep (xmlrpc/end-point 
                {:hello (fn [n] (str "Hello, " n "!"))}))
    (def handler (app 
        ["hello"] {:get "Hello!"} 
        ["xml"] ep))
    
    (run-jetty #'handler {:port 3000 :join? false})

In this application `/` is a 404, `/hello` returns "Hello!", and `/xml` is the xmlrpc handler.

### Compojure example:

This snippet implements the same server as the one above for Moustache:

    (require '[necessary-evil.core :as xmlrpc])  
    (use 'ring.adapter.jetty)   
    (use 'compojure.core)
    
    (def ep (xmlrpc/end-point 
                {:hello (fn [n] (str "Hello, " n "!"))}))

    (defroutes handler 
        (GET "/hello" [] "Hello!")
        (ANY "/xml" [] ep))

    (run-jetty #'handler {:port 3000 :join? false})

Just as in the moustache example above,  `/` is a 404, `/hello` returns "Hello!", and `/xml` is the xmlrpc handler.

### xml-rpc mappings

This table describes the mapping of clojure datastructures and types
to XML-RPC types

<table style="width: 100%">
    <thead>
    <tr><th>XML-RPC Element</th><th>Clojure or Java type</th></tr>
    </thead>
    <tbody>
        <tr><td>array</td><td>clojure.lang.IPersistentVector</td></tr>
        <tr><td>base64</td><td>byte-array</td></tr>
        <tr><td>boolean</td><td>java.lang.Boolean</td></tr>
        <tr><td>dateTime.iso8601</td><td>org.joda.time.DateTime</td></tr>
        <tr><td>double</td><td>java.lang.Double</td></tr>
        <tr><td>i4</td><td>java.lang.Integer</td></tr>
        <tr><td>int</td><td>java.lang.Integer</td></tr>
        <tr><td>struct</td><td>clojure.lang.IPersistantMap â€” <em>clojure.lang.Keyword keys</em></td></tr>
        <tr><td><em>no element</em></td><td>java.lang.String</td></tr>
    </tbody>
</table>

**Note:** `nil` is conspicuously absent from the list of types; this is because the spec for xml-rpc itself does not include any canonical representation.

It is possible to extend the support to additional data types trivially. All the details of parsing and unparsing the various value types is handled in the `necessary-evil.value` namespace with the multimethod `parse-value` and the protocol `ValueTypeElem`. Simple implement the appropriate pair for each of these in your own code.

## Changes from 1.2 to 1.2.1
 
 * Addes UTF-8 character set to content type headers for both client and server. Thanks to Laurent Petit for this 
   fix.

## Changes from 1.1 to 1.2

 * Fixes a bug with values containing XML special characters not being escaped
 * Support for [Null support extension](http://ontosys.com/xml-rpc/extensions.php) with the `necessary-evil.value/allow-nils` form.
 * Uses non-snapshot `clj-time`

## Changes from 1.0 to 1.1

 * `fault` handling code is now in its own namespace: `necessary-evil.fault`
 * `necessary-evil.fault` now includes `attempt-all` macro to stream line 
     writing code that may generate faults in multiple stages.

## Thanks

Thanks to the following people for their feedback and assistance:

 * [Raynes](https://github.com/Raynes/) (also for letting me
 steal from his `clj-xmlrpc` code).
 * [Amalloy](https://github.com/amalloy/) 
 * [kumarshantanu](https://bitbucket.org/kumarshantanu)
 * [semperos](https://github.com/semperos)
 * [laurentpetit](https://github.com/laurentpetit)

## License

Copyright (C) 2010, 2011 Andrew Brehaut

Distributed under the Eclipse Public License, the same as Clojure.


